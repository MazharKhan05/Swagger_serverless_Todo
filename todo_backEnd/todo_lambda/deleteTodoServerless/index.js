/**
 *  This code was generated by SwaggerHub from the following API:
 * 
 *  https://app.swaggerhub.com/api/KHANMAZHAR72/todo/1.0.0
 *  
 *  The content of this file will never be modified after initial
 *  generation--adding or changing parameters will not be reflected
 *  here.  You can regenerate this with the latest definition by
 *  deleting the lambda and allowing SwaggerHub to recreate it
 **/
const { DynamoDBClient,ScanCommand,DeleteItemCommand,BatchWriteItemCommand } = require('@aws-sdk/client-dynamodb');
const REGION = `us-east-1`; // Put your correct aws region
const ddbClient = new DynamoDBClient({ region: REGION });
exports.handler =async function(event, context, callback) {
  // header: (required)  login-token to authorize user
  
  // path: (required)  todo id to delete
  let isStateSet = false
  const actionPerformerOrgId = 'OrgID#98765'
  const actionPerformerUserId = 'UserID#12345' //the action performer, extract userId from jwt token
  let response={
    message: '',
    errType: '',
    statusCode: ''
  };
  let deleteParams = {}
  console.log(event)
  const authToken = event.authToken; 
  const id = event.todoId;
  
  if(!authToken || authToken === ""){
    response.message = 'Not a Authenticated user.';
    response.statusCode = 401;
    return response;
  }
  if(!id){
    response.message = 'Invalid input provided.';
    response.statusCode = 400;
    return response;
  }
  
  const getTodoParams = {
    TableName: 'TodosList',
    Key: {
      PK: {S: `${actionPerformerOrgId}:${actionPerformerUserId}`},
      SK: {S: `TodoId#${id}`},
    }
  };
  
  const params = {
    TableName: 'TodosList',
    FilterExpression : '#PK = :PK and  begins_with (#SK , :SK )',
    ExpressionAttributeNames: {
        "#PK": "PK",
        "#SK": "SK"
    },
    ExpressionAttributeValues: {
        ':PK': {'S': `${actionPerformerOrgId}:${actionPerformerUserId}`},
        ':SK': {'S': `TodoId#${id}`}
    }
  };
  try {
    let deleteTodos=[]
    let tempTodos=[]
    let tempTodo = {}
    const tododata = await ddbClient.send(new ScanCommand(params));
    console.log(tododata.Items, "todos after filtering...");
    deleteTodos = tododata.Items;
    deleteTodos.map(todo=>{
        tempTodo= {
          "DeleteRequest": { 
            "Key" : {
              "PK": todo["PK"],
              "SK": todo["SK"]
            }
          }
        }
        // tempTodo["PK"] = todo["PK"]
        // tempTodo["SK"] = todo["SK"]
        tempTodos.push(tempTodo);
        tempTodo = {};
    })
    deleteParams["RequestItems"]={
      'TodosList': tempTodos
    };
    console.log("batchDelete params ", deleteParams)
    if(tododata.$metadata && tododata.$metadata.httpStatusCode === 200)isStateSet = true
    } catch (err) {
      response.message = err.errorMessage;
      response.errType = err.errorType;
      response.statusCode = 500;
      return response;
    }
    //after fetching todo and all its history, delete all records
    
      if(isStateSet){
        try{
          
          const batchOptRes = await ddbClient.send(new BatchWriteItemCommand(deleteParams))
          console.log(batchOptRes, "if any item are left unprocessed they will be shown here...")
          // const data = await ddbClient.send(new DeleteItemCommand(params));
          if(Object.keys(batchOptRes.UnprocessedItems).length === 0){
            response.message = 'Successfully deleted todo';
            response.statusCode = 200;
          }
        } catch (err) {
            response.message = err.errorMessage;
            response.errType = err.errorType;
            response.statusCode = 500;
            return response;
        }
      }
    return response
};